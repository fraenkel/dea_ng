package starting

import (
	"dea/config"
	"dea/container"
	"dea/droplet"
	"dea/health_check"
	"dea/task"
	"dea/utils"
	"errors"
	"github.com/cloudfoundry/gordon"
	"io/ioutil"
	"os"
	"path"
	"sync"
	"time"
)

type userFacingError struct {
	s string
}

func (u *userFacingError) Error() string {
	return u.s
}

var HealthCheckFailed = &userFacingError{"failed to start accepting connections"}
var MissingStartCommand = &userFacingError{"missing start command"}

type State string

const (
	STATE_BORN     State = "BORN"
	STATE_STARTING State = "STARTING"
	STATE_RUNNING  State = "RUNNING"
	STATE_STOPPING State = "STOPPING"
	STATE_STOPPED  State = "STOPPED"
	STATE_CRASHED  State = "CRASHED"
	STATE_DELETED  State = "DELETED"
	STATE_RESUMING State = "RESUMING"

	NPROC_LIMIT = 512
)

type link_callback func(err error)

type Transition struct {
	From State
	To   State
}

func (t Transition) Name() string {
	return string(t.From) + string(t.To)
}

type Instance struct {
	raw_attributes map[string]interface{}
	startData      StartData
	path           *string

	instance_id string
	// private_instance_id is internal id that represents the instance,
	// which is generated by DEA itself. Currently, we broadcast it to
	// all routers. Routers use that as sticky session of the instance.
	private_instance_id string

	instance_path string
	warden_job_id uint32
	state         State
	state_times   map[State]time.Time

	exitStatus      int64
	exitDescription string
	hooks           map[string]string
	statCollector   StatCollector
	*task.Task
	utils.EventEmitter
	dropletRegistry    droplet.DropletRegistry
	stagedInfo         map[string]interface{}
	localIp            string
	healthCheckTimeout time.Duration
	healthCheck        health_check.HealthCheck
	crashesPath        string
	InstancePromises
	*sync.Mutex
	bindMounts []map[string]string
}

type healthcheckCallback struct {
	result    *bool
	condition *sync.Cond
}

func newHealthCheckCallback() *healthcheckCallback {
	mutex := sync.Mutex{}
	cond := sync.NewCond(&mutex)
	return &healthcheckCallback{condition: cond}
}

func (hcc *healthcheckCallback) Success() {
	hcc.condition.L.Lock()
	defer hcc.condition.L.Unlock()

	result := true
	hcc.result = &result
	hcc.condition.Signal()
}

func (hcc *healthcheckCallback) Failure() {
	hcc.condition.L.Lock()
	defer hcc.condition.L.Unlock()

	result := false
	hcc.result = &result
	hcc.condition.Signal()
}

func (hcc *healthcheckCallback) Wait() {
	hcc.condition.L.Lock()
	hcc.condition.Wait()
}

func NewInstance(raw_attributes map[string]interface{}, config *config.Config, dr droplet.DropletRegistry, localIp string) *Instance {
	sdata := NewStartData(raw_attributes)

	// Generate unique ID
	instance_id := getString(raw_attributes, "instance_id")
	if instance_id == "" {
		instance_id = utils.UUID()
	}

	// Contatenate 2 UUIDs to generate a 32 chars long private_instance_id
	private_id := getString(raw_attributes, "private_instance_id")
	if private_id == "" {
		private_id = utils.UUID() + utils.UUID()
	}

	i := &Instance{
		raw_attributes:      raw_attributes,
		startData:           sdata,
		state:               STATE_BORN,
		state_times:         make(map[State]time.Time),
		instance_id:         instance_id,
		private_instance_id: private_id,
		exitStatus:          -1,
		localIp:             localIp,
		healthCheckTimeout:  config.MaximumHealthCheckTimeout,
		crashesPath:         config.CrashesPath,
		Task:                task.NewTask(config.WardenSocket, nil),
		EventEmitter:        utils.NewEventEmitter(),
		dropletRegistry:     dr,
		Mutex:               &sync.Mutex{},
		bindMounts:          config.BindMounts,
	}

	i.InstancePromises = &instancePromises{i}

	if config != nil {
		i.hooks = config.Hooks
	}

	i.Logger = utils.Logger("Instance", map[string]interface{}{
		"instance_id":         i.Id(),
		"instance_index":      i.Index(),
		"private_instance_id": i.private_instance_id,
		"application_id":      i.ApplicationId(),
		"application_version": i.ApplicationVersion(),
		"application_name":    i.ApplicationName(),
	})

	warden_handle := getString(raw_attributes, "warden_handle")
	hostPort := getUInt(raw_attributes, "instance_host_port")
	containerPort := getUInt(raw_attributes, "instance_container_port")
	i.Container.Setup(warden_handle, uint32(hostPort), uint32(containerPort))

	i.statCollector = NewStatCollector(i.Container)

	return i
}

func (i *Instance) Validate() error {
	return nil
}

func (i *Instance) Setup() {
	i.setup_stat_collector()
	i.setup_link()
	i.setup_crash_handler()
}

func (i *Instance) CCPartition() string {
	return i.startData.CC_partition
}

func (i *Instance) SetId() {
	i.instance_id = utils.UUID()
}

func (i *Instance) Id() string {
	return i.instance_id
}

func (i *Instance) Index() int {
	return i.startData.Instance_index
}

func (i *Instance) ApplicationId() string {
	return i.startData.Application_id
}

func (i *Instance) SetApplicationVersion(version string) {
	i.startData.Application_version = version
}

func (i *Instance) ApplicationVersion() string {
	return i.startData.Application_version
}

func (i *Instance) ApplicationName() string {
	return i.startData.Application_name
}
func (i *Instance) ApplicationUris() []string {
	return i.startData.Application_uris
}

func (i *Instance) SetApplicationUris(uris []string) {
	i.startData.Application_uris = uris
}

func (i *Instance) DropletSHA1() string {
	return i.startData.Droplet_sha1
}
func (i *Instance) DropletUri() string {
	return i.startData.Droplet_uri
}
func (i *Instance) droplet() droplet.Droplet {
	return i.dropletRegistry.Get(i.DropletSHA1())
}

func (i *Instance) StartCommand() string {
	return i.startData.Start_command
}
func (i *Instance) Limits() LimitsData {
	return i.startData.LimitsData
}
func (i *Instance) Environment() map[string]string {
	return i.startData.Env
}
func (i *Instance) Services() []ServiceData {
	return i.startData.ServicesData
}

func (i *Instance) PrivateInstanceId() string {
	return i.private_instance_id
}

func (i *Instance) MemoryLimit() config.Memory {
	return config.Memory(i.Limits().MemMb) * config.Mebi
}

func (i *Instance) DiskLimit() config.Disk {
	return config.Disk(i.Limits().DiskMb) * config.MB
}

func (i *Instance) FileDescriptorLimit() uint64 {
	return i.Limits().Fds
}

func (i *Instance) SetState(newState State) {
	transition := Transition{i.state, newState}
	curTime := time.Now()

	i.Lock()

	i.state = newState
	i.state_times[newState] = curTime

	i.Unlock()

	i.Emit(transition)
}

func (i *Instance) State() State {
	i.Lock()
	defer i.Unlock()

	return i.state
}

func (i *Instance) StateTime(state State) time.Time {
	i.Lock()
	defer i.Unlock()

	return i.state_times[state]

}

func (i *Instance) StateTimestamp() time.Time {
	i.Lock()
	defer i.Unlock()

	return i.state_times[i.state]
}

func (i *Instance) SetExitStatus(status int64, description string) {
	i.Lock()
	defer i.Unlock()

	i.exitStatus = status
	i.exitDescription = description
}

func (i *Instance) ExitStatus() int64 {
	i.Lock()
	defer i.Unlock()

	return i.exitStatus
}

func (i *Instance) ExitDescription() string {
	i.Lock()
	defer i.Unlock()

	return i.exitDescription
}

func (i *Instance) IsConsumingMemory() bool {
	switch i.State() {
	case STATE_BORN, STATE_STARTING, STATE_RUNNING, STATE_STOPPING:
		return true
	}
	return false
}

func (i *Instance) IsConsumingDisk() bool {
	switch i.State() {
	case STATE_BORN, STATE_STARTING, STATE_RUNNING, STATE_STOPPING, STATE_CRASHED:
		return true
	}
	return false
}

func (i *Instance) IsPathAvailable() bool {
	switch i.State() {
	case STATE_RUNNING, STATE_CRASHED:
		return true
	}
	return false
}

func (i *Instance) Path() (string, error) {
	if i.path == nil {
		if !i.IsPathAvailable() {
			return "", errors.New("Instance path unavailable")
		}
		if i.Container.Path() == "" {
			return "", errors.New("Warden container path not present")
		}

		path := container_relative_path(i.Container.Path())
		i.path = &path
	}

	return *i.path, nil
}

func (i *Instance) attributes_and_stats() map[string]interface{} {
	m := make(map[string]interface{})
	i.startData.MarshalMap(m)

	stats := i.GetStats()
	m["used_memory_in_bytes"] = stats.UsedMemory
	m["used_disk_in_bytes"] = stats.UsedDisk
	m["computed_pcpu"] = stats.ComputedPCPU

	return m
}

func (i *Instance) GetStats() Stats {
	return *i.statCollector.GetStats()
}

func (i *Instance) setup_crash_handler() {
	// Resuming to crashed state
	i.EventEmitter.On(Transition{STATE_RESUMING, STATE_CRASHED}, func() {
		i.crash_handler()
	})

	i.EventEmitter.On(Transition{STATE_STARTING, STATE_CRASHED}, func() {
		i.crash_handler()
	})

	i.EventEmitter.On(Transition{STATE_RUNNING, STATE_CRASHED}, func() {
		i.crash_handler()
	})
}

func (i *Instance) crash_handler() {
	err := i.Promise_crash_handler()
	if err != nil {
		i.Logger.Warnd(map[string]interface{}{"error": err},
			"droplet.crash-handler.error")
	}
}

func (i *Instance) Start(callback func(error)) {
	var err error
	defer func() {
		if r := recover(); r != nil {
			switch r.(type) {
			case error:
				err = r.(error)
			default:
				err = errors.New("failed to start")
			}
		}

		if err != nil {
			// An error occured while starting, mark as crashed
			i.exitDescription = err.Error()
			i.SetState(STATE_CRASHED)
		}

		if callback != nil {
			callback(err)
		}
	}()

	i.Logger.Info("droplet.starting")

	err = i.Promise_state([]State{STATE_BORN}, STATE_STARTING)
	if err != nil {
		return
	}
	// Concurrently download droplet and setup container
	err = utils.Parallel_promises(
		i.Promise_droplet,
		i.Promise_container)
	if err != nil {
		return
	}

	err = utils.Sequence_promises(
		i.Promise_extract_droplet,
		func() error { return i.Promise_exec_hook_script("before_start") },
		i.Promise_start)
	if err != nil {
		return
	}

	i.On(Transition{STATE_STARTING, STATE_CRASHED}, func() {
		i.cancel_health_check()
	})

	// Fire off link so that the health check can be cancelled when the
	// instance crashes before the health check completes.

	i.Link()

	healthy, err := i.Promise_health_check()
	if err != nil {
		return
	}

	if healthy {
		err = i.Promise_state([]State{STATE_STARTING}, STATE_RUNNING)
		if err == nil {
			i.Logger.Info("droplet.healthy")
			err = i.Promise_exec_hook_script("after_start")
		}
	} else {
		i.Logger.Warn("droplet.unhealthy")
		err = HealthCheckFailed
	}
}

func (i *Instance) Stop() error {
	startTime := time.Now()

	i.Logger.Info("droplet.stopping")
	i.Promise_exec_hook_script("before_stop")

	err := i.Promise_state([]State{STATE_RUNNING, STATE_STARTING}, STATE_STOPPING)
	if err != nil {
		goto done
	}

	err = i.Promise_exec_hook_script("after_stop")
	err = i.Promise_stop()
	if err != nil {
		goto done
	}

	err = i.Promise_state([]State{STATE_STOPPING}, STATE_STOPPED)

done:
	duration := time.Since(startTime)

	if err != nil {
		// An error occured while starting, mark as crashed
		i.exitDescription = err.Error()
		i.SetState(STATE_CRASHED)
	}

	operation := "stop instance"
	if err != nil {
		i.Logger.Warnf("Failed: %s (took %s)", operation, duration)
		i.Logger.Warnf("Exception: %s %s", operation, err.Error())
	} else {
		i.Logger.Infof("Delivered: %s (took %s)", operation, duration)
	}

	if err != nil {
		// An error occured while starting, mark as crashed
		i.exitDescription = err.Error()
		i.SetState(STATE_CRASHED)
	}

	return err
}

func (i *Instance) setup_stat_collector() {
	i.EventEmitter.On(Transition{STATE_RESUMING, STATE_RUNNING}, func() {
		i.statCollector.Start()
	})

	i.EventEmitter.On(Transition{STATE_STARTING, STATE_RUNNING}, func() {
		i.statCollector.Start()
	})

	i.EventEmitter.On(Transition{STATE_RUNNING, STATE_STOPPING}, func() {
		i.statCollector.Stop()
	})

	i.EventEmitter.On(Transition{STATE_RUNNING, STATE_CRASHED}, func() {
		i.statCollector.Stop()
	})
}

func (i *Instance) setup_link() {
	// Resuming to running state
	i.EventEmitter.On(Transition{STATE_RESUMING, STATE_RUNNING}, func() {
		i.Link()
	})
}

func (i *Instance) cancel_health_check() {
	if i.healthCheck != nil {
		i.healthCheck.Destroy()
		i.healthCheck = nil
	}
}

func (i Instance) ContainerPort() uint32 {
	return i.Container.NetworkPort(container.CONTAINER_PORT)
}

func (i Instance) HostPort() uint32 {
	return i.Container.NetworkPort(container.HOST_PORT)
}

func (i *Instance) staged_info() map[string]interface{} {
	if i.stagedInfo == nil {
		tmpdir, err := ioutil.TempDir("", "instance")
		if err != nil {
			i.Logger.Warnf("Failed to create a temporary directory: %s", err.Error())
			return nil
		}
		defer os.RemoveAll(tmpdir)

		staging_file_name := "staging_info.yml"
		copied_file_name := path.Join(tmpdir, staging_file_name)
		i.Copy_out_request(path.Join("/home/vcap", staging_file_name), tmpdir)

		stagedInfo := new(map[string]interface{})
		err = utils.Yaml_Load(copied_file_name, stagedInfo)
		if err != nil {
			return nil
		}
		i.stagedInfo = *stagedInfo
	}

	return i.stagedInfo
}

func (i *Instance) Snapshot_attributes() map[string]interface{} {
	sysdrainUrls := make([]string, 0, 1)
	for _, s := range i.Services() {
		drainUrl := s.Syslog_drain_url
		if drainUrl != "" {
			sysdrainUrls = append(sysdrainUrls, drainUrl)
		}
	}

	return map[string]interface{}{
		"cc_partition": i.CCPartition(),

		"instance_id":         i.Id(),
		"instance_index":      i.Index(),
		"private_instance_id": i.private_instance_id,

		"warden_handle": i.Container.Handle(),
		"limits":        i.Limits(),

		"environment": i.Environment(),
		"services":    i.Services(),

		"application_id":      i.ApplicationId(),
		"application_version": i.ApplicationVersion(),
		"application_name":    i.ApplicationName(),
		"application_uris":    i.ApplicationUris(),

		"droplet_sha1": i.DropletSHA1(),
		"droplet_uri":  i.DropletUri,

		"start_command": i.StartCommand(),

		"state": i.State(),

		"warden_job_id":           i.warden_job_id,
		"warden_container_path":   i.Container.Path(),
		"warden_host_ip":          i.Container.HostIp(),
		"instance_host_port":      i.HostPort(),
		"instance_container_port": i.ContainerPort(),

		"syslog_drain_urls": sysdrainUrls,

		"state_starting_timestamp": i.StateTime(STATE_STARTING),
	}
}

func container_relative_path(root string, parts ...string) string {
	front := path.Join(root, "tmp", "rootfs", "home", "vcap")
	back := path.Join(parts...)
	return path.Join(front, back)
}

func determine_exit_description(link_response *warden.LinkResponse) string {
	info := link_response.GetInfo()
	if info == nil {
		return "cannot be determined"
	}

	if info.Events != nil && len(info.Events) > 0 {
		return info.Events[0]
	}

	return "app instance exited"
}
