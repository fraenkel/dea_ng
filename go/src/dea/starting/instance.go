package starting

import (
	"dea"
	"dea/config"
	"dea/health_check"
	"dea/task"
	"dea/utils"
	"errors"
	"github.com/cloudfoundry/gordon"
	"io/ioutil"
	"os"
	"path"
	"sync"
	"time"
)

type userFacingError struct {
	s string
}

func (u *userFacingError) Error() string {
	return u.s
}

var HealthCheckFailed = &userFacingError{"failed to start accepting connections"}
var MissingStartCommand = &userFacingError{"missing start command"}

const (
	NPROC_LIMIT = 512
)

var STATES = []dea.State{dea.STATE_BORN, dea.STATE_STARTING, dea.STATE_RUNNING, dea.STATE_STOPPING, dea.STATE_STOPPED, dea.STATE_CRASHED, dea.STATE_DELETED, dea.STATE_RESUMING, dea.STATE_EVACUATING}

type link_callback func(err error)

type Transition struct {
	From dea.State
	To   dea.State
}

func (t Transition) Name() string {
	return string(t.From) + string(t.To)
}

type Instance struct {
	raw_attributes map[string]interface{}
	startData      StartData
	path           *string

	instance_id string
	// private_instance_id is internal id that represents the instance,
	// which is generated by DEA itself. Currently, we broadcast it to
	// all routers. Routers use that as sticky session of the instance.
	private_instance_id string

	instance_path string
	warden_job_id uint32
	state         dea.State
	state_times   map[dea.State]time.Time

	exitStatus      int64
	exitDescription string
	hooks           config.HookConfig
	dea.StatCollector
	*task.Task
	utils.EventEmitter
	dropletRegistry    dea.DropletRegistry
	stagedInfo         map[string]interface{}
	localIp            string
	healthCheckTimeout time.Duration
	healthCheck        health_check.HealthCheck
	crashesPath        string
	InstancePromises
	*sync.Mutex
	bindMounts []config.BindMount
}

type healthcheckCallback struct {
	result    *bool
	condition *sync.Cond
}

func newHealthCheckCallback() *healthcheckCallback {
	mutex := sync.Mutex{}
	cond := sync.NewCond(&mutex)
	return &healthcheckCallback{condition: cond}
}

func (hcc *healthcheckCallback) Success() {
	hcc.condition.L.Lock()
	defer hcc.condition.L.Unlock()

	result := true
	hcc.result = &result
	hcc.condition.Signal()
}

func (hcc *healthcheckCallback) Failure() {
	hcc.condition.L.Lock()
	defer hcc.condition.L.Unlock()

	result := false
	hcc.result = &result
	hcc.condition.Signal()
}

func (hcc *healthcheckCallback) Wait() {
	hcc.condition.L.Lock()
	hcc.condition.Wait()
}

func NewInstance(raw_attributes map[string]interface{}, config *config.Config, dr dea.DropletRegistry, localIp string) *Instance {
	sdata, err := NewStartData(raw_attributes)
	if err != nil {
		return nil
	}

	// Generate unique ID
	instance_id := getString(raw_attributes, "instance_id")
	if instance_id == "" {
		instance_id = utils.UUID()
	}

	// Contatenate 2 UUIDs to generate a 32 chars long private_instance_id
	private_id := getString(raw_attributes, "private_instance_id")
	if private_id == "" {
		private_id = utils.UUID() + utils.UUID()
	}

	i := &Instance{
		raw_attributes:      raw_attributes,
		startData:           sdata,
		state_times:         make(map[dea.State]time.Time),
		instance_id:         instance_id,
		private_instance_id: private_id,
		exitStatus:          -1,
		localIp:             localIp,
		healthCheckTimeout:  config.MaximumHealthCheckTimeout,
		crashesPath:         config.CrashesPath,
		Task:                task.NewTask(config.WardenSocket, nil),
		EventEmitter:        utils.NewEventEmitter(),
		dropletRegistry:     dr,
		Mutex:               &sync.Mutex{},
		bindMounts:          config.BindMounts,
		hooks:               config.Hooks,
	}
	i.InstancePromises = &instancePromises{i}

	i.Logger = utils.Logger("Instance", map[string]interface{}{
		"instance_id":         i.Id(),
		"instance_index":      i.Index(),
		"private_instance_id": i.private_instance_id,
		"application_id":      i.ApplicationId(),
		"application_version": i.ApplicationVersion(),
		"application_name":    i.ApplicationName(),
	})

	i.SetState(dea.STATE_BORN)

	// recover from a snapshot
	for _, s := range STATES {
		k := "state_" + string(s) + "_timestamp"
		if ts := getInt64(raw_attributes, k); ts != 0 {
			i.state_times[s] = time.Unix(0, ts)
		}
	}

	warden_handle := getString(raw_attributes, "warden_handle")
	hostPort := getUInt(raw_attributes, "instance_host_port")
	containerPort := getUInt(raw_attributes, "instance_container_port")
	i.Container.Setup(warden_handle, uint32(hostPort), uint32(containerPort))

	i.StatCollector = NewStatCollector(i.Container)

	return i
}

func (i *Instance) Validate() error {
	return nil
}

func (i *Instance) Setup() {
	i.setup_stat_collector()
	i.setup_link()
	i.setup_crash_handler()
}

func (i *Instance) StartMessage() dea.StartMessage {
	return i.startData
}

func (i *Instance) CCPartition() string {
	return i.startData.CC_partition
}

func (i *Instance) SetId() {
	i.instance_id = utils.UUID()
}

func (i *Instance) Id() string {
	return i.instance_id
}

func (i *Instance) Index() int {
	return i.startData.Instance_index
}

func (i *Instance) ApplicationId() string {
	return i.startData.Application_id
}

func (i *Instance) SetApplicationVersion(version string) {
	i.startData.Application_version = version
}

func (i *Instance) ApplicationVersion() string {
	return i.startData.Application_version
}

func (i *Instance) ApplicationName() string {
	return i.startData.Application_name
}
func (i *Instance) ApplicationUris() []string {
	return i.startData.Application_uris
}

func (i *Instance) SetApplicationUris(uris []string) {
	i.startData.Application_uris = uris
}

func (i *Instance) DropletSHA1() string {
	return i.startData.Droplet_sha1
}
func (i *Instance) DropletUri() string {
	return i.startData.Droplet_uri
}
func (i *Instance) droplet() dea.Droplet {
	return i.dropletRegistry.Get(i.DropletSHA1())
}

func (i *Instance) StartCommand() string {
	return i.startData.Start_command
}
func (i *Instance) Limits() LimitsData {
	return i.startData.LimitsData
}
func (i *Instance) Environment() map[string]string {
	return i.startData.Env
}
func (i *Instance) Services() []ServiceData {
	return i.startData.ServicesData
}

func (i *Instance) PrivateInstanceId() string {
	return i.private_instance_id
}

func (i *Instance) MemoryLimit() config.Memory {
	return config.Memory(i.Limits().MemMb) * config.Mebi
}

func (i *Instance) DiskLimit() config.Disk {
	return config.Disk(i.Limits().DiskMb) * config.MB
}

func (i *Instance) FileDescriptorLimit() uint64 {
	return i.Limits().Fds
}

func (i *Instance) SetState(newState dea.State) {
	transition := Transition{i.state, newState}
	curTime := time.Now()

	i.Lock()

	i.state = newState
	i.state_times[newState] = curTime

	i.Unlock()

	i.Emit(transition)
}

func (i *Instance) State() dea.State {
	i.Lock()
	defer i.Unlock()

	return i.state
}

func (i *Instance) StateTime(state dea.State) time.Time {
	i.Lock()
	defer i.Unlock()

	return i.state_times[state]

}

func (i *Instance) StateTimestamp() time.Time {
	i.Lock()
	defer i.Unlock()

	return i.state_times[i.state]
}

func (i *Instance) SetExitStatus(status int64, description string) {
	i.Lock()
	defer i.Unlock()

	i.exitStatus = status
	i.exitDescription = description
}

func (i *Instance) ExitStatus() int64 {
	i.Lock()
	defer i.Unlock()

	return i.exitStatus
}

func (i *Instance) ExitDescription() string {
	i.Lock()
	defer i.Unlock()

	return i.exitDescription
}

func (i *Instance) IsConsumingMemory() bool {
	switch i.State() {
	case dea.STATE_BORN, dea.STATE_STARTING, dea.STATE_RUNNING, dea.STATE_STOPPING:
		return true
	}
	return false
}

func (i *Instance) IsConsumingDisk() bool {
	switch i.State() {
	case dea.STATE_BORN, dea.STATE_STARTING, dea.STATE_RUNNING, dea.STATE_STOPPING, dea.STATE_CRASHED:
		return true
	}
	return false
}

func (i *Instance) IsPathAvailable() bool {
	switch i.State() {
	case dea.STATE_RUNNING, dea.STATE_CRASHED:
		return true
	}
	return false
}

func (i *Instance) Path() (string, error) {
	if i.path == nil {
		if !i.IsPathAvailable() {
			return "", errors.New("Instance path unavailable")
		}
		if i.Container.Path() == "" {
			return "", errors.New("Warden container path not present")
		}

		path := container_relative_path(i.Container.Path())
		i.path = &path
	}

	return *i.path, nil
}

func (i *Instance) Attributes_and_stats() map[string]interface{} {
	m := make(map[string]interface{})
	i.startData.MarshalMap(m)

	// add state information
	m["state"] = i.state
	m["state_timestamp"] = i.state_times[i.state].UnixNano()
	for k, v := range i.state_times {
		m["state_"+string(k)+"_timestamp"] = v.UnixNano()
	}

	stats := i.GetStats()
	m["used_memory_in_bytes"] = stats.UsedMemory
	m["used_disk_in_bytes"] = stats.UsedDisk
	m["computed_pcpu"] = stats.ComputedPCPU

	return m
}

func (i *Instance) GetStats() dea.Stats {
	return i.StatCollector.GetStats()
}

func (i *Instance) setup_crash_handler() {
	// Resuming to crashed state
	i.EventEmitter.On(Transition{dea.STATE_RESUMING, dea.STATE_CRASHED}, func() {
		i.crash_handler(nil)
	})

	i.EventEmitter.On(Transition{dea.STATE_STARTING, dea.STATE_CRASHED}, func() {
		i.crash_handler(nil)
	})

	i.EventEmitter.On(Transition{dea.STATE_RUNNING, dea.STATE_CRASHED}, func() {
		i.crash_handler(nil)
	})
}

func (i *Instance) crash_handler(callback func(error) error) {
	utils.Async_promise(i.Promise_crash_handler, func(err error) error {
		if err != nil {
			i.Logger.Warnd(map[string]interface{}{"error": err},
				"droplet.crash-handler.error")
		}

		if callback != nil {
			return callback(err)
		}
		return nil
	})
}

func (i *Instance) Start(callback func(error) error) {
	start_promise := func() error {
		i.Logger.Info("droplet.starting")

		if err := i.Promise_state([]dea.State{dea.STATE_BORN}, dea.STATE_STARTING); err != nil {
			return err
		}

		// Concurrently download droplet and setup container
		if err := utils.Parallel_promises(
			i.Promise_droplet,
			i.Promise_container); err != nil {
			return err
		}

		if err := utils.Sequence_promises(
			i.Promise_extract_droplet,
			func() error { return i.Promise_exec_hook_script("before_start", i.hooks.BeforeStart) },
			i.Promise_start); err != nil {
			return err
		}

		i.On(Transition{dea.STATE_STARTING, dea.STATE_CRASHED}, func() {
			i.cancel_health_check()
		})

		// Fire off link so that the health check can be cancelled when the
		// instance crashes before the health check completes.

		i.Link(nil)

		healthy, err := i.Promise_health_check()
		if err != nil {
			return err
		}

		if healthy {
			err = i.Promise_state([]dea.State{dea.STATE_STARTING}, dea.STATE_RUNNING)
			if err == nil {
				i.Logger.Info("droplet.healthy")
				err = i.Promise_exec_hook_script("after_start", i.hooks.AfterStart)
			}
		} else {
			i.Logger.Warn("droplet.unhealthy")
			err = HealthCheckFailed
		}

		return err
	}

	go i.ResolveAndLog(start_promise, "instance.start", func(err error) error {
		if err != nil {
			// An error occured while starting, mark as crashed
			i.exitDescription = err.Error()
			i.SetState(dea.STATE_CRASHED)
		}

		if callback != nil {
			return callback(err)
		}
		return nil
	})
}

func (i *Instance) Stop(callback dea.Callback) {
	stopping_promise := func() error {

		i.Logger.Info("droplet.stopping")

		if err := i.Promise_exec_hook_script("before_stop", i.hooks.BeforeStop); err != nil {
			return err
		}

		if err := i.Promise_state([]dea.State{dea.STATE_RUNNING, dea.STATE_STARTING}, dea.STATE_STOPPING); err != nil {
			return err
		}

		if err := i.Promise_exec_hook_script("after_stop", i.hooks.AfterStop); err != nil {
			return err
		}

		if err := i.Promise_stop(); err != nil {
			return err
		}

		return i.Promise_state([]dea.State{dea.STATE_STOPPING}, dea.STATE_STOPPED)
	}

	go i.ResolveAndLog(stopping_promise, "instance.stop", func(err error) error {
		if callback != nil {
			return callback(err)
		}
		return nil
	})

}

func (i *Instance) setup_stat_collector() {
	i.EventEmitter.On(Transition{dea.STATE_RESUMING, dea.STATE_RUNNING}, func() {
		i.StatCollector.Start()
	})

	i.EventEmitter.On(Transition{dea.STATE_STARTING, dea.STATE_RUNNING}, func() {
		i.StatCollector.Start()
	})

	i.EventEmitter.On(Transition{dea.STATE_RUNNING, dea.STATE_STOPPING}, func() {
		i.StatCollector.Stop()
	})

	i.EventEmitter.On(Transition{dea.STATE_RUNNING, dea.STATE_CRASHED}, func() {
		i.StatCollector.Stop()
	})
}

func (i *Instance) setup_link() {
	// Resuming to running state
	i.EventEmitter.On(Transition{dea.STATE_RESUMING, dea.STATE_RUNNING}, func() {
		i.Link(nil)
	})
}

func (i *Instance) cancel_health_check() {
	if i.healthCheck != nil {
		i.healthCheck.Destroy()
		i.healthCheck = nil
	}
}

func (i Instance) ContainerPort() uint32 {
	return i.Container.NetworkPort(dea.CONTAINER_PORT)
}

func (i Instance) HostPort() uint32 {
	return i.Container.NetworkPort(dea.HOST_PORT)
}

func (i *Instance) staged_info() map[string]interface{} {
	if i.stagedInfo == nil {
		tmpdir, err := ioutil.TempDir("", "instance")
		if err != nil {
			i.Logger.Warnf("Failed to create a temporary directory: %s", err.Error())
			return nil
		}
		defer os.RemoveAll(tmpdir)

		staging_file_name := "staging_info.yml"
		copied_file_name := path.Join(tmpdir, staging_file_name)
		i.Copy_out_request(path.Join("/home/vcap", staging_file_name), tmpdir)

		stagedInfo := new(map[string]interface{})
		err = utils.Yaml_Load(copied_file_name, stagedInfo)
		if err != nil {
			return nil
		}
		i.stagedInfo = *stagedInfo
	}

	return i.stagedInfo
}

func (i *Instance) Snapshot_attributes() map[string]interface{} {
	sysdrainUrls := make([]string, 0, 1)
	for _, s := range i.Services() {
		drainUrl := s.Syslog_drain_url
		if drainUrl != "" {
			sysdrainUrls = append(sysdrainUrls, drainUrl)
		}
	}

	return map[string]interface{}{
		"cc_partition": i.CCPartition(),

		"instance_id":         i.Id(),
		"instance_index":      i.Index(),
		"private_instance_id": i.private_instance_id,

		"warden_handle": i.Container.Handle(),
		"limits":        i.Limits(),

		"environment": i.Environment(),
		"services":    i.Services(),

		"application_id":      i.ApplicationId(),
		"application_version": i.ApplicationVersion(),
		"application_name":    i.ApplicationName(),
		"application_uris":    i.ApplicationUris(),

		"droplet_sha1": i.DropletSHA1(),
		"droplet_uri":  i.DropletUri(),

		"start_command": i.StartCommand(),

		"state": i.State(),

		"warden_job_id":           i.warden_job_id,
		"warden_container_path":   i.Container.Path(),
		"warden_host_ip":          i.Container.HostIp(),
		"instance_host_port":      i.HostPort(),
		"instance_container_port": i.ContainerPort(),

		"syslog_drain_urls": sysdrainUrls,

		"state_starting_timestamp": i.StateTime(dea.STATE_STARTING),
	}
}

func container_relative_path(root string, parts ...string) string {
	front := path.Join(root, "tmp", "rootfs", "home", "vcap")
	back := path.Join(parts...)
	return path.Join(front, back)
}

func determine_exit_description(link_response *warden.LinkResponse) string {
	info := link_response.GetInfo()
	if info == nil {
		return "cannot be determined"
	}

	if info.Events != nil && len(info.Events) > 0 {
		return info.Events[0]
	}

	return "app instance exited"
}
